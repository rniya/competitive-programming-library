---
title: Mo's Algorithm
documentation_of: ./Mo.hpp
---

## 概要
区間の伸縮による更新が容易にできるときに，事前にクエリの区間を適切に並び替えることで効率的に処理するアルゴリズム．

以下に記す時間計算量においては伸縮 1 回あたりの計算量を $O(1)$ としている．

| メンバ関数                                           | 効果                                                                     | 時間計算量         |
| ---------------------------------------------------- | ------------------------------------------------------------------------ | ------------------ |
| `Mo(n)`                                              | 要素数 $n$ の列に関するクエリを処理するとして初期化する．                | $O(1)$             |
| `add(l, r)`                                          | $[l, r)$ についてのクエリを追加する．この追加順はクエリの解答順に則る．  | $O(1)$             |
| `run(add_left, add_right, del_left, del_right, rem)` | 伸縮操作の関数及び解答の関数を引数にしてクエリを処理する．               | $O(N\sqrt{Q} + Q)$ |
| `run(add, del, rem)`                                 | 伸縮操作の関数 (左右で等価) 及び解答の関数を引数にしてクエリを処理する． | $O(N\sqrt{Q} + Q)$ |

## 問題例
- [Codeforces Round #221 (Div. 1) D. Tree and Queries](https://codeforces.com/contest/375/problem/D)
  - 部分木クエリはオイラーツアー順に並べることにより区間クエリになる．
  種類数や転倒数に関連するクエリは Mo's algorithm で扱いやすい．

## Links
- [Mo's algorithm とその上位互換の話 - あなたは嘘つきですかと聞かれたら「YES」と答えるブログ](https://snuke.hatenablog.com/entry/2016/07/01/000000)
- [Mo's algorithm - ei1333の日記](https://ei1333.hateblo.jp/entry/2017/09/11/211011)
