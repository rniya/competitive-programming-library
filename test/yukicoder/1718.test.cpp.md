---
data:
  _extendedDependsOn:
  - icon: ':heavy_check_mark:'
    path: tree/Rerooting.hpp
    title: "\u5168\u65B9\u4F4D\u6728 dp"
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _isVerificationFailed: false
  _pathExtension: cpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    '*NOT_SPECIAL_COMMENTS*': ''
    PROBLEM: https://yukicoder.me/problems/no/1718
    links:
    - https://yukicoder.me/problems/no/1718
  bundledCode: "#line 1 \"test/yukicoder/1718.test.cpp\"\n#define PROBLEM \"https://yukicoder.me/problems/no/1718\"\
    \n\n#include <iostream>\n#include <utility>\n#line 1 \"tree/Rerooting.hpp\"\n\
    #include <cassert>\n#include <functional>\n#include <vector>\n\ntemplate <class\
    \ key_t, class sum_t = key_t> struct Rerooting {\n    struct edge {\n        int\
    \ from, to;\n        key_t cost;\n        sum_t dp, ndp;\n        edge(int from,\
    \ int to, key_t cost, sum_t dp, sum_t ndp) : from(from), to(to), cost(cost), dp(dp),\
    \ ndp(ndp) {}\n    };\n    using F = std::function<sum_t(sum_t, sum_t)>;\n   \
    \ using G = std::function<sum_t(sum_t, edge)>;\n\n    int n;\n    std::vector<std::vector<edge>>\
    \ g;\n    const F op;\n    const G mapping;\n    const sum_t id;\n\n    Rerooting(int\
    \ n, const F& op, const G& mapping, const sum_t& id)\n        : n(n), g(n), op(op),\
    \ mapping(mapping), id(id), sub(n, id), dp(n, id) {}\n\n    void add_edge(int\
    \ u, int v, key_t w) {\n        assert(0 <= u and u < n);\n        assert(0 <=\
    \ v and v < n);\n        g[u].emplace_back(u, v, w, id, id);\n        g[v].emplace_back(v,\
    \ u, w, id, id);\n    }\n\n    std::vector<sum_t> solve() {\n        dfs_sub(0,\
    \ -1);\n        dfs_all(0, -1, id);\n        return dp;\n    }\n\nprivate:\n \
    \   std::vector<sum_t> sub, dp;\n\n    void dfs_sub(int v, int p) {\n        for\
    \ (auto& e : g[v]) {\n            if (e.to == p) continue;\n            dfs_sub(e.to,\
    \ v);\n            e.dp = mapping(sub[e.to], e);\n            sub[v] = op(sub[v],\
    \ e.dp);\n        }\n    }\n\n    void dfs_all(int v, int p, sum_t top) {\n  \
    \      sum_t cur = id;\n        for (int i = 0; i < (int)g[v].size(); i++) {\n\
    \            auto& e = g[v][i];\n            e.ndp = cur;\n            if (e.to\
    \ == p) e.dp = mapping(top, e);\n            cur = op(cur, e.dp);\n        }\n\
    \        dp[v] = cur;\n        cur = id;\n        for (int i = (int)g[v].size()\
    \ - 1; i >= 0; i--) {\n            auto& e = g[v][i];\n            if (e.to !=\
    \ p) dfs_all(e.to, v, op(e.ndp, cur));\n            cur = op(cur, e.dp);\n   \
    \     }\n    }\n};\n#line 6 \"test/yukicoder/1718.test.cpp\"\n\nstruct S {\n \
    \   int back, go;\n    bool must;\n    S(int back, int go, bool must) : back(back),\
    \ go(go), must(must) {}\n};\n\nint main() {\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n\
    \    int N, K;\n    std::cin >> N >> K;\n    std::vector<bool> D(N, false);\n\
    \    auto op = [](S l, S r) { return S(l.back + r.back, std::min(l.go + r.back,\
    \ l.back + r.go), l.must | r.must); };\n    auto mapping = [&](S x, auto e) {\n\
    \        bool must = x.must | D[e.to];\n        return S(x.back + (must ? 2 :\
    \ 0), x.go + (must ? 1 : 0), must);\n    };\n    Rerooting<int, S> G(N, op, mapping,\
    \ S(0, 0, false));\n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n\
    \        std::cin >> u >> v;\n        G.add_edge(--u, --v, 1);\n    }\n    for\
    \ (; K--;) {\n        int d;\n        std::cin >> d;\n        D[--d] = true;\n\
    \    }\n\n    auto ans = G.solve();\n    for (int i = 0; i < N; i++) std::cout\
    \ << ans[i].go << '\\n';\n    return 0;\n}\n"
  code: "#define PROBLEM \"https://yukicoder.me/problems/no/1718\"\n\n#include <iostream>\n\
    #include <utility>\n#include \"tree/Rerooting.hpp\"\n\nstruct S {\n    int back,\
    \ go;\n    bool must;\n    S(int back, int go, bool must) : back(back), go(go),\
    \ must(must) {}\n};\n\nint main() {\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n\
    \    int N, K;\n    std::cin >> N >> K;\n    std::vector<bool> D(N, false);\n\
    \    auto op = [](S l, S r) { return S(l.back + r.back, std::min(l.go + r.back,\
    \ l.back + r.go), l.must | r.must); };\n    auto mapping = [&](S x, auto e) {\n\
    \        bool must = x.must | D[e.to];\n        return S(x.back + (must ? 2 :\
    \ 0), x.go + (must ? 1 : 0), must);\n    };\n    Rerooting<int, S> G(N, op, mapping,\
    \ S(0, 0, false));\n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n\
    \        std::cin >> u >> v;\n        G.add_edge(--u, --v, 1);\n    }\n    for\
    \ (; K--;) {\n        int d;\n        std::cin >> d;\n        D[--d] = true;\n\
    \    }\n\n    auto ans = G.solve();\n    for (int i = 0; i < N; i++) std::cout\
    \ << ans[i].go << '\\n';\n    return 0;\n}"
  dependsOn:
  - tree/Rerooting.hpp
  isVerificationFile: true
  path: test/yukicoder/1718.test.cpp
  requiredBy: []
  timestamp: '2022-12-27 01:20:30+09:00'
  verificationStatus: TEST_ACCEPTED
  verifiedWith: []
documentation_of: test/yukicoder/1718.test.cpp
layout: document
redirect_from:
- /verify/test/yukicoder/1718.test.cpp
- /verify/test/yukicoder/1718.test.cpp.html
title: test/yukicoder/1718.test.cpp
---
