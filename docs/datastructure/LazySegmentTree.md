## 概要
遅延伝搬を採用することで, Segment Tree には行えなかった区間更新を可能にしたデータ構造. モノイド $(S, \cdot, e)$ と $S$ から $S$ への写像の集合 $F$ について,

- $F$ はモノイド : 結合律が成立し, 単位元 $id$ が存在する ($id$ は恒等写像) .
- $F$ は $S$ について準同型 : $\forall f \in F,\ \forall a, b \in S,\ f(a \cdot b) = f(a) \cdot f(b)$
- $F$ は写像の合成について閉じている : $\forall f, g \in F,\ g \circ f \in F,\ \forall a \in S,\ (g \circ f)(a) = g(f(a))$

を満たしていることが要件となる. このとき, 区間全体に $f \in F$ を作用させたり区間取得が $O(\log n)$ で可能となる.

| メンバ関数                           | 効果                                                                                                                                                                      | 時間計算量  |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------- |
| `LazySegmentTree(n, f, g, h, e, id)` | 要素数 $n$ の単位元で初期化する. ここで, $f$ は $S$ 上の二項演算, $g$ は $F$ から $S$ への作用, $h$ は $F$ 上の二項演算, $e$ は $S$ の単位元, $id$ は $F$ の単位元である. | $O(n)$      |
| `set(k, x)`                          | $k$ 番目の要素に $x$ を代入する. ここで, この後各クエリに答えるには `build()` を挟んで親ノードの情報を更新してからでないといけないことに注意.                             | $O(1)$      |
| `build()`                            | `set` された情報をもとに Segment Tree を構築する.                                                                                                                         | $O(n)$      |
| `update(a, b, x)`                    | 区間 $[a, b)$ の要素について作用素 $x$ を適用する.                                                                                                                        | $O(\log n)$ |
| `set_val(k, x)`                      |                                                                                                                                                                           | $O(\log n)$ |
| `query(a, b)`                        | 区間 $[a, b)$ の要素について二項演算を適用した結果を返す. 結合律が成立することからこの結果は一意に定まる.                                                                 | $O(\log n)$ |
| `operator[k]`                        | $k$ 番目の要素を返す.                                                                                                                                                     | $O(\log n)$ |
| `find_first(l, check)`               | $[l, x]$ (右端点を含む) が `check` を満たすような最小の $x$ を返す. 存在しない場合は $n$ を返す.                                                                          | $O(\log n)$ |
| `find_last(r, check)`                | $[x, r)$ (左端点を含む) が `check` を満たすような最大の $x$ を返す. 存在しない場合は $-1$ を返す.                                                                         | $O(\log n)$ |

## Remark
- [Educational Codeforces Round 101 (Rated for Div. 2) F. Power Sockets](https://codeforces.com/contest/1469/problem/F)
区間加算区間和取得において `find_first` といった二分探索関数を用いる際には, 始点を厳密に定めないと想定し得ない挙動を起こすので注意.